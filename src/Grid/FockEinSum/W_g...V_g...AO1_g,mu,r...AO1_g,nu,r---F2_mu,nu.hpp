/*
Generated by EigenEinSum

Recommended filename:
W_g...V_g...AO1_g,mu,r...AO1_g,nu,r---F2_mu,nu.hpp

Einsum expression:
W(g), V(g), AO1(g, mu, r), AO1(g, nu, r) -> F2(mu, nu)

The einsum expression is decomposed into:
W(g), V(g) -> WV(g)
WV(g), AO1(g, mu, r) -> WVAO1(g, r, mu)
WVAO1(g, r, mu), AO1(g, nu, r) -> F2(mu, nu)

The index paths are derived to be:
TOP
├── g
├── mu
│   └── r
│       └── g
└── nu
    └── mu
        └── r
            └── g
*/
{
	[[maybe_unused]] const int mu_len = AO1.dimension(1);
	assert( mu_len == F2.dimension(0) );
	[[maybe_unused]] const int nu_len = AO1.dimension(1);
	assert( nu_len == F2.dimension(1) );
	[[maybe_unused]] const int g_len = W.dimension(0);
	assert( g_len == V.dimension(0) );
	assert( g_len == AO1.dimension(0) );
	[[maybe_unused]] const int r_len = AO1.dimension(2);
	assert( r_len == AO1.dimension(2) );
	EigenTensor<1> WV(g_len);
	EigenTensor<3> WVAO1(g_len, r_len, mu_len);
	WV.setZero();
	WVAO1.setZero();
	double* WV_ = &WV(0);
	const double* W_ = &W(0);
	const double* V_ = &V(0);
	#pragma omp simd simdlen(8) aligned(WV_, W_, V_: 64)
	for ( int g = 0; g < g_len; g++ ){
		WV_[g] += W_[g] * V_[g];
	}
	for ( int mu = 0; mu < mu_len; mu++ ){
		for ( int r = 0; r < r_len; r++ ){
			double* WVAO1_rmu = &WVAO1(0, r, mu);
			const double* WV_ = &WV(0);
			const double* AO1_mur = &AO1(0, mu, r);
			#pragma omp simd simdlen(8) aligned(WVAO1_rmu, WV_, AO1_mur: 64)
			for ( int g = 0; g < g_len; g++ ){
				WVAO1_rmu[g] += WV_[g] * AO1_mur[g];
			}
		}
	}
	for ( int nu = 0; nu < nu_len; nu++ ){
		for ( int mu = 0; mu < mu_len; mu++ ){
			for ( int r = 0; r < r_len; r++ ){
				double F2munu = 0;
				const double* WVAO1_rmu = &WVAO1(0, r, mu);
				const double* AO1_nur = &AO1(0, nu, r);
				#pragma omp simd simdlen(8) reduction(+: F2munu) aligned(WVAO1_rmu, AO1_nur: 64)
				for ( int g = 0; g < g_len; g++ ){
					F2munu += WVAO1_rmu[g] * AO1_nur[g];
				}
				F2(mu, nu) += F2munu;
			}
		}
	}
}
